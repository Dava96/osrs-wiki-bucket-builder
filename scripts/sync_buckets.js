import axios from 'axios';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
/** URL for the OSRS Wiki API. */
const API_URL = 'https://oldschool.runescape.wiki/api.php';
/** Base URL for raw page content. */
const RAW_URL = 'https://oldschool.runescape.wiki/w/';
/** Namespace ID for Buckets. */
const BUCKET_NAMESPACE = 9592;
/**
 * Mappings from Wiki types to TypeScript types.
 */
const TYPE_MAPPING = {
    'TEXT': 'string',
    'INTEGER': 'number',
    'DECIMAL': 'number',
    'DOUBLE': 'number',
    'BOOLEAN': 'boolean',
    'PAGE': 'string',
};
/**
 * Fetches the list of all pages in the Bucket namespace.
 * @returns A list of page titles (e.g., "Bucket:Infobox item").
 */
async function fetchBucketList() {
    console.log('Fetching bucket list...');
    const response = await axios.get(API_URL, {
        params: {
            action: 'query',
            list: 'allpages',
            apnamespace: BUCKET_NAMESPACE,
            aplimit: 'max',
            format: 'json',
        },
    });
    const pages = response.data.query.allpages;
    return pages.map((p) => p.title);
}
/**
 * Fetches and parses the raw JSON content of a bucket definition.
 * @param title The full title of the bucket page.
 * @returns A partial record of field definitions, or null if parsing failed.
 */
async function fetchBucketSchema(title) {
    try {
        const response = await axios.get(`${RAW_URL}${encodeURIComponent(title)}`, {
            params: { action: 'raw' }
        });
        // The response data is the raw JSON string (or object if axios parsing kicked in)
        const data = typeof response.data === 'string' ? JSON.parse(response.data) : response.data;
        return data;
    }
    catch (e) {
        console.error(`Failed to fetch schema for ${title}:`, e);
        return null;
    }
}
/**
 * Converts a raw field definition to our internal BucketField interface.
 * @param fieldName The name of the field.
 * @param raw The raw field definition from the Wiki.
 */
function processField(fieldName, raw) {
    const baseType = TYPE_MAPPING[raw.type] || 'string'; // Default to string if unknown
    const finalType = raw.repeated ? `${baseType}[]` : baseType;
    return {
        name: fieldName,
        type: finalType,
    };
}
/**
 * Generates the TypeScript definition file content.
 */
function generateDefinitionFile(definitions) {
    const lines = [];
    lines.push('// Auto-generated by scripts/sync_buckets.ts');
    lines.push('// Do not edit this file manually.');
    lines.push('');
    // Generate interfaces for each bucket
    for (const def of definitions) {
        // Convert bucket name to PascalCase for the interface name
        // e.g., "infobox_item" -> "InfoboxItem"
        const interfaceName = toPascalCase(def.originalName);
        lines.push(`/** definition for ${def.originalName} */`);
        lines.push(`export interface ${interfaceName} {`);
        for (const field of def.fields) {
            lines.push(`  /** ${field.name} */`);
            // Handle special characters in field names if any (though usually they are snake_case)
            const safeName = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(field.name) ? field.name : `'${field.name}'`;
            lines.push(`  ${safeName}: ${field.type};`);
        }
        lines.push('}');
        lines.push('');
    }
    // Generate Runtime Field Map (for Wildcard expansion)
    lines.push('/** Runtime list of fields for each bucket. */');
    lines.push('export const BUCKET_FIELDS: Record<string, string[]> = {');
    for (const def of definitions) {
        // We use the original bucket name as the key
        const fieldNames = def.fields.map(f => `'${f.name}'`).join(', ');
        lines.push(`  '${def.originalName}': [${fieldNames}],`);
    }
    lines.push('};');
    lines.push('');
    // Generate the Registry
    lines.push('/** Registry mapping bucket names to their types. */');
    lines.push('export interface BucketRegistry {');
    for (const def of definitions) {
        const interfaceName = toPascalCase(def.originalName);
        lines.push(`  '${def.originalName}': ${interfaceName};`);
    }
    lines.push('}');
    lines.push('');
    lines.push('/** Union of all valid bucket names. */');
    lines.push('export type BucketName = keyof BucketRegistry;');
    return lines.join('\n');
}
/**
 * Helper to convert snake_case or whitespace strings to PascalCase.
 */
function toPascalCase(str) {
    // Replace non-alphanumeric chars with space, then Title Case, then remove spaces
    return str
        .replace(/[^a-zA-Z0-9]/g, ' ')
        .split(' ')
        .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
        .join('');
}
async function main() {
    const bucketList = await fetchBucketList();
    console.log(`Found ${bucketList.length} buckets.`);
    const definitions = [];
    for (const title of bucketList) {
        // Remove "Bucket:" prefix
        const rawName = title.replace(/^Bucket:/, '');
        // Normalized name for usage in queries (keeping it as is, or lowercase? Wiki seems to use snake_case)
        const bucketId = rawName.toLowerCase();
        console.log(`Processing ${bucketId}...`);
        const schema = await fetchBucketSchema(title);
        if (schema) {
            const fields = Object.entries(schema).map(([k, v]) => processField(k, v));
            definitions.push({
                name: toPascalCase(bucketId),
                originalName: bucketId,
                fields
            });
        }
    }
    const content = generateDefinitionFile(definitions);
    const outDir = path.join(__dirname, '../src/generated');
    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir, { recursive: true });
    }
    fs.writeFileSync(path.join(outDir, 'definitions.ts'), content);
    console.log('Successfully generated src/generated/definitions.ts');
}
main().catch(console.error);
//# sourceMappingURL=sync_buckets.js.map
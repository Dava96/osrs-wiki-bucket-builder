import axios from 'axios';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/** User-Agent sent with all Wiki API requests. */
const USER_AGENT = '@dava96/osrs-wiki-bucket-builder (https://github.com/Dava96/osrs-wiki-bucket-builder)';

/** Shared axios client with User-Agent header. */
const apiClient = axios.create({
    headers: { 'User-Agent': USER_AGENT },
});

/** URL for the OSRS Wiki API. */
const API_URL = 'https://oldschool.runescape.wiki/api.php';

/** Base URL for raw page content. */
const RAW_URL = 'https://oldschool.runescape.wiki/w/';

/** Namespace ID for Buckets. */
const BUCKET_NAMESPACE = 9592;

/** Path to the local cache file. */
const CACHE_PATH = path.join(__dirname, '.bucket_cache.json');

/**
 * Valid TypeScript types for bucket fields.
 */
type TSType = 'string' | 'number' | 'boolean' | 'string[]' | 'number[]' | 'boolean[]';

/**
 * Interface for the raw JSON field definition from the Wiki.
 */
interface RawBucketField {
    type: string;
    repeated?: boolean;
}

/**
 * Interface representing a processed field in our system.
 */
interface BucketField {
    name: string;
    type: TSType;
}

/**
 * Interface representing a processed Bucket definition.
 */
interface BucketDefinition {
    name: string;
    originalName: string;
    fields: BucketField[];
}

/**
 * Cached schema entry — stores the raw schema keyed by bucket ID.
 */
interface CacheEntry {
    hash: string;
    schema: Record<string, RawBucketField>;
}

type SchemaCache = Record<string, CacheEntry>;

/**
 * Mappings from Wiki types to TypeScript types.
 */
const TYPE_MAPPING: Record<string, 'string' | 'number' | 'boolean'> = {
    'TEXT': 'string',
    'INTEGER': 'number',
    'DECIMAL': 'number',
    'DOUBLE': 'number',
    'BOOLEAN': 'boolean',
    'PAGE': 'string',
};

/**
 * Loads the local schema cache from disk.
 */
function loadCache(): SchemaCache {
    try {
        if (fs.existsSync(CACHE_PATH)) {
            return JSON.parse(fs.readFileSync(CACHE_PATH, 'utf-8'));
        }
    } catch {
        console.log('Cache file corrupted, starting fresh.');
    }
    return {};
}

/**
 * Saves the schema cache to disk.
 */
function saveCache(cache: SchemaCache): void {
    fs.writeFileSync(CACHE_PATH, JSON.stringify(cache, null, 2));
}

/**
 * Generates a SHA-256 hash of a schema for cache comparison.
 */
function hashSchema(schema: Record<string, RawBucketField>): string {
    return crypto.createHash('sha256').update(JSON.stringify(schema)).digest('hex');
}

/**
 * Fetches the list of all pages in the Bucket namespace.
 * @returns A list of page titles (e.g., "Bucket:Infobox item").
 */
async function fetchBucketList(): Promise<string[]> {
    console.log('Fetching bucket list...');
    const response = await apiClient.get(API_URL, {
        params: {
            action: 'query',
            list: 'allpages',
            apnamespace: BUCKET_NAMESPACE,
            aplimit: 'max',
            format: 'json',
        },
    });

    const pages = response.data.query.allpages;
    return pages.map((p: any) => p.title);
}

/**
 * Fetches and parses the raw JSON content of a bucket definition.
 * @param title The full title of the bucket page.
 * @returns A partial record of field definitions, or null if parsing failed.
 */
async function fetchBucketSchema(title: string): Promise<Record<string, RawBucketField> | null> {
    try {
        const response = await apiClient.get(`${RAW_URL}${encodeURIComponent(title)}`, {
            params: { action: 'raw' }
        });

        const data = typeof response.data === 'string' ? JSON.parse(response.data) : response.data;
        return data as Record<string, RawBucketField>;
    } catch (e) {
        console.error(`Failed to fetch schema for ${title}:`, e);
        return null;
    }
}

/**
 * Converts a raw field definition to our internal BucketField interface.
 * @param fieldName The name of the field.
 * @param raw The raw field definition from the Wiki.
 */
function processField(fieldName: string, raw: RawBucketField): BucketField {
    const baseType = TYPE_MAPPING[raw.type] || 'string';
    const finalType = raw.repeated ? `${baseType}[]` as TSType : baseType;

    return {
        name: fieldName,
        type: finalType,
    };
}

/**
 * Generates the TypeScript definition file content.
 */
function generateDefinitionFile(definitions: BucketDefinition[]): string {
    const lines: string[] = [];
    lines.push('// Auto-generated by scripts/sync_buckets.ts');
    lines.push('// Do not edit this file manually.');
    lines.push('');

    for (const def of definitions) {
        const interfaceName = toPascalCase(def.originalName);

        lines.push(`/** definition for ${def.originalName} */`);
        lines.push(`export interface ${interfaceName} {`);
        for (const field of def.fields) {
            lines.push(`  /** ${field.name} */`);
            const safeName = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(field.name) ? field.name : `'${field.name}'`;
            lines.push(`  ${safeName}: ${field.type};`);
        }
        lines.push('}');
        lines.push('');
    }

    lines.push('/** Runtime list of fields for each bucket. */');
    lines.push('export const BUCKET_FIELDS: Record<string, string[]> = {');
    for (const def of definitions) {
        const fieldNames = def.fields.map(f => `'${f.name}'`).join(', ');
        lines.push(`  '${def.originalName}': [${fieldNames}],`);
    }
    lines.push('};');
    lines.push('');

    lines.push('/** Registry mapping bucket names to their types. */');
    lines.push('export interface BucketRegistry {');
    for (const def of definitions) {
        const interfaceName = toPascalCase(def.originalName);
        lines.push(`  '${def.originalName}': ${interfaceName};`);
    }
    lines.push('}');
    lines.push('');

    lines.push('/** Union of all valid bucket names. */');
    lines.push('export type BucketName = keyof BucketRegistry;');

    return lines.join('\n');
}

/**
 * Helper to convert snake_case or whitespace strings to PascalCase.
 */
function toPascalCase(str: string): string {
    return str
        .replace(/[^a-zA-Z0-9]/g, ' ')
        .split(' ')
        .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
        .join('');
}

async function main() {
    const cache = loadCache();
    const bucketList = await fetchBucketList();
    console.log(`Found ${bucketList.length} buckets.`);

    const definitions: BucketDefinition[] = [];
    const newCache: SchemaCache = {};
    let fetchedCount = 0;
    let cachedCount = 0;

    for (const title of bucketList) {
        const rawName = title.replace(/^Bucket:/, '');
        const bucketId = rawName.toLowerCase().replace(/\s+/g, '_');

        const schema = await fetchBucketSchema(title);

        if (schema) {
            const hash = hashSchema(schema);
            const cached = cache[bucketId];

            if (cached && cached.hash === hash) {
                cachedCount++;
            } else {
                fetchedCount++;
                console.log(`Updated: ${bucketId}`);
            }

            newCache[bucketId] = { hash, schema };
            const fields = Object.entries(schema).map(([k, v]) => processField(k, v));
            definitions.push({
                name: toPascalCase(bucketId),
                originalName: bucketId,
                fields,
            });
        }
    }

    console.log(`${cachedCount} unchanged, ${fetchedCount} updated.`);
    saveCache(newCache);

    const content = generateDefinitionFile(definitions);
    const outDir = path.join(__dirname, '../src/generated');
    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir, { recursive: true });
    }

    const outputPath = path.join(outDir, 'definitions.ts');
    const existingContent = fs.existsSync(outputPath) ? fs.readFileSync(outputPath, 'utf-8') : '';

    if (content === existingContent) {
        console.log('No changes detected — definitions.ts is already up to date.');
    } else {
        fs.writeFileSync(outputPath, content);
        console.log('Successfully generated src/generated/definitions.ts');
    }
}

main().catch(console.error);

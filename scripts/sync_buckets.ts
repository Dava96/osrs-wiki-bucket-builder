import axios from 'axios';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/** URL for the OSRS Wiki API. */
const API_URL = 'https://oldschool.runescape.wiki/api.php';

/** Base URL for raw page content. */
const RAW_URL = 'https://oldschool.runescape.wiki/w/';

/** Namespace ID for Buckets. */
const BUCKET_NAMESPACE = 9592;

/**
 * Valid TypeScript types for bucket fields.
 */
type TSType = 'string' | 'number' | 'boolean' | 'string[]' | 'number[]' | 'boolean[]';

/**
 * Interface for the raw JSON field definition from the Wiki.
 */
interface RawBucketField {
    type: string;
    repeated?: boolean;
}

/**
 * Interface representing a processed field in our system.
 */
interface BucketField {
    name: string;
    type: TSType;
}

/**
 * Interface representing a processed Bucket definition.
 */
interface BucketDefinition {
    name: string;
    originalName: string; // The wiki name, e.g. "infobox_item"
    fields: BucketField[];
}

/**
 * Mappings from Wiki types to TypeScript types.
 */
const TYPE_MAPPING: Record<string, 'string' | 'number' | 'boolean'> = {
    'TEXT': 'string',
    'INTEGER': 'number',
    'DECIMAL': 'number',
    'DOUBLE': 'number',
    'BOOLEAN': 'boolean',
    'PAGE': 'string',
};

/**
 * Fetches the list of all pages in the Bucket namespace.
 * @returns A list of page titles (e.g., "Bucket:Infobox item").
 */
async function fetchBucketList(): Promise<string[]> {
    console.log('Fetching bucket list...');
    const response = await axios.get(API_URL, {
        params: {
            action: 'query',
            list: 'allpages',
            apnamespace: BUCKET_NAMESPACE,
            aplimit: 'max',
            format: 'json',
        },
    });

    const pages = response.data.query.allpages;
    return pages.map((p: any) => p.title);
}

/**
 * Fetches and parses the raw JSON content of a bucket definition.
 * @param title The full title of the bucket page.
 * @returns A partial record of field definitions, or null if parsing failed.
 */
async function fetchBucketSchema(title: string): Promise<Record<string, RawBucketField> | null> {
    try {
        const response = await axios.get(`${RAW_URL}${encodeURIComponent(title)}`, {
            params: { action: 'raw' }
        });

        // The response data is the raw JSON string (or object if axios parsing kicked in)
        const data = typeof response.data === 'string' ? JSON.parse(response.data) : response.data;
        return data as Record<string, RawBucketField>;
    } catch (e) {
        console.error(`Failed to fetch schema for ${title}:`, e);
        return null;
    }
}

/**
 * Converts a raw field definition to our internal BucketField interface.
 * @param fieldName The name of the field.
 * @param raw The raw field definition from the Wiki.
 */
function processField(fieldName: string, raw: RawBucketField): BucketField {
    const baseType = TYPE_MAPPING[raw.type] || 'string'; // Default to string if unknown
    const finalType = raw.repeated ? `${baseType}[]` as TSType : baseType;

    return {
        name: fieldName,
        type: finalType,
    };
}

/**
 * Generates the TypeScript definition file content.
 */
function generateDefinitionFile(definitions: BucketDefinition[]): string {
    const lines: string[] = [];
    lines.push('// Auto-generated by scripts/sync_buckets.ts');
    lines.push('// Do not edit this file manually.');
    lines.push('');

    // Generate interfaces for each bucket
    for (const def of definitions) {
        // Convert bucket name to PascalCase for the interface name
        // e.g., "infobox_item" -> "InfoboxItem"
        const interfaceName = toPascalCase(def.originalName);

        lines.push(`/** definition for ${def.originalName} */`);
        lines.push(`export interface ${interfaceName} {`);
        for (const field of def.fields) {
            lines.push(`  /** ${field.name} */`);
            // Handle special characters in field names if any (though usually they are snake_case)
            const safeName = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(field.name) ? field.name : `'${field.name}'`;
            lines.push(`  ${safeName}: ${field.type};`);
        }
        lines.push('}');
        lines.push('');
    }

    // Generate Runtime Field Map (for Wildcard expansion)
    lines.push('/** Runtime list of fields for each bucket. */');
    lines.push('export const BUCKET_FIELDS: Record<string, string[]> = {');
    for (const def of definitions) {
        // We use the original bucket name as the key
        const fieldNames = def.fields.map(f => `'${f.name}'`).join(', ');
        lines.push(`  '${def.originalName}': [${fieldNames}],`);
    }
    lines.push('};');
    lines.push('');

    // Generate the Registry
    lines.push('/** Registry mapping bucket names to their types. */');
    lines.push('export interface BucketRegistry {');
    for (const def of definitions) {
        const interfaceName = toPascalCase(def.originalName);
        lines.push(`  '${def.originalName}': ${interfaceName};`);
    }
    lines.push('}');
    lines.push('');

    lines.push('/** Union of all valid bucket names. */');
    lines.push('export type BucketName = keyof BucketRegistry;');

    return lines.join('\n');
}

/**
 * Helper to convert snake_case or whitespace strings to PascalCase.
 */
function toPascalCase(str: string): string {
    // Replace non-alphanumeric chars with space, then Title Case, then remove spaces
    return str
        .replace(/[^a-zA-Z0-9]/g, ' ')
        .split(' ')
        .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
        .join('');
}

async function main() {
    const bucketList = await fetchBucketList();
    console.log(`Found ${bucketList.length} buckets.`);

    const definitions: BucketDefinition[] = [];

    for (const title of bucketList) {
        // Remove "Bucket:" prefix
        const rawName = title.replace(/^Bucket:/, '');
        // Force strict snake_case as per user request: "snake_case and nothing else"
        const bucketId = rawName.toLowerCase().replace(/\s+/g, '_');

        console.log(`Processing ${bucketId}...`);
        const schema = await fetchBucketSchema(title);

        if (schema) {
            const fields = Object.entries(schema).map(([k, v]) => processField(k, v));
            definitions.push({
                name: toPascalCase(bucketId),
                originalName: bucketId,
                fields,
            });
        }
    }

    const content = generateDefinitionFile(definitions);
    const outDir = path.join(__dirname, '../src/generated');
    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir, { recursive: true });
    }

    fs.writeFileSync(path.join(outDir, 'definitions.ts'), content);
    console.log('Successfully generated src/generated/definitions.ts');
}

main().catch(console.error);
